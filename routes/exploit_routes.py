from flask import Blueprint, request, jsonify, render_template, send_file, redirect, make_response
from markupsafe import Markup
import os
import json
import socket
import datetime
from utils.logger import get_logger
from services.metasploit_auto import (
    run_metasploit_auto, 
    list_exploit_reports, 
    get_exploit_report,
    check_metasploit_available,
    EXPLOIT_MAP
)

# Configuration du logger
logger = get_logger('exploit_routes')

exploit_bp = Blueprint("exploit", __name__)

@exploit_bp.route("/auto", methods=["POST"])
def auto_exploit():
    """API pour lancer un exploit automatiquement"""
    logger.info("Requête reçue pour lancer un exploit")
    
    try:
        if request.is_json:
            data = request.get_json()
        else:
            # Si la requête vient d'un formulaire
            data = {
                "vuln_id": request.form.get("vuln_id"),
                "ip": request.form.get("ip"),
                "port": request.form.get("port"),
                "options": {}
            }
            
            # Récupérer le module manuel si spécifié
            manual_module = request.form.get("manual_module")
            if manual_module and manual_module.strip():
                data["manual_module"] = manual_module.strip()
            
            # Ajouter les options personnalisées du formulaire
            for key, value in request.form.items():
                if key.startswith("option_") and value:
                    option_name = key.replace("option_", "")
                    data["options"][option_name] = value
        
        # Vérifier les paramètres requis
        required_fields = ["vuln_id", "ip", "port"]
        for field in required_fields:
            if not data.get(field):
                logger.warning(f"Paramètre manquant: {field}")
                return jsonify({"error": f"Le paramètre '{field}' est requis"}), 400
        
        # Vérifier si Metasploit est disponible
        if not check_metasploit_available():
            error_msg = "Metasploit n'est pas disponible sur le système. Veuillez installer Metasploit pour utiliser cette fonctionnalité."
            logger.error(error_msg)
            return jsonify({"error": error_msg}), 503
        
        # Vérifier si un module manuel a été spécifié
        options = data.get("options", {})
        
        # Si un module manuel a été spécifié, l'utiliser directement
        manual_module = request.form.get("manual_module") if not request.is_json else data.get("manual_module")
        if manual_module and manual_module.strip():
            logger.info(f"Utilisation d'un module Metasploit spécifié manuellement: {manual_module}")
            # Ajouter le module manuel aux options
            data["manual_module"] = manual_module.strip()
        
        # Lancer l'exploitation
        result = run_metasploit_auto(data, options)
        
        # Retourner le résultat en JSON pour les API ou rediriger vers la page des résultats
        if request.is_json or request.headers.get("Accept") == "application/json":
            return jsonify(result)
        else:
            # Format HTML pour l'affichage
            return render_template_for_exploit_result(result, data)
            
    except Exception as e:
        logger.error(f"Erreur lors de l'exploitation: {e}", exc_info=True)
        return jsonify({"error": f"Erreur: {str(e)}"}), 500

@exploit_bp.route("/reports", methods=["GET"])
def list_reports():
    """Liste tous les rapports d'exploitation"""
    logger.info("Accès à la liste des rapports d'exploitation")
    
    try:
        reports = list_exploit_reports()
        
        if request.headers.get("Accept") == "application/json":
            return jsonify({"reports": reports})
        else:
            # Debugger le contenu de 'reports' pour s'assurer qu'il est bien formaté
            logger.debug(f"Nombre de rapports trouvés: {len(reports)}")
            return render_template("exploit_reports.html", reports=reports)
    except Exception as e:
        logger.error(f"Erreur lors de la récupération des rapports: {e}", exc_info=True)
        return jsonify({"error": f"Erreur: {str(e)}"}), 500

@exploit_bp.route("/reports/<filename>", methods=["GET"])
def get_report(filename):
    """Récupère un rapport d'exploitation spécifique"""
    logger.info(f"Accès au rapport d'exploitation: {filename}")
    
    try:
        exploit_dir = "exploit_reports"
        file_path = os.path.join(exploit_dir, filename)
        
        if not os.path.exists(file_path):
            logger.warning(f"Rapport introuvable: {filename}")
            return jsonify({"error": "Rapport introuvable"}), 404
        
        # Sécuriser le chemin pour éviter les path traversal
        if not os.path.abspath(file_path).startswith(os.path.abspath(exploit_dir)):
            logger.warning(f"Tentative d'accès non autorisé: {file_path}")
            return jsonify({"error": "Accès non autorisé"}), 403
        
        with open(file_path, "r") as f:
            report = json.load(f)
            
        if request.headers.get("Accept") == "application/json":
            return jsonify(report)
        else:
            # Ajouter la date de génération du rapport
            generated_on = datetime.datetime.now().strftime("%d/%m/%Y %H:%M:%S")
            
            # Format la sortie pour l'affichage HTML
            return render_template("exploit_report.html", 
                                   report=report, 
                                   filename=filename,
                                   generated_on=generated_on)
    except Exception as e:
        logger.error(f"Erreur lors de la récupération du rapport: {e}", exc_info=True)
        return jsonify({"error": f"Erreur: {str(e)}"}), 500

@exploit_bp.route("/reports/<filename>/html", methods=["GET"])
def download_report_html(filename):
    """Télécharge un rapport d'exploitation au format HTML"""
    logger.info(f"Téléchargement du rapport HTML pour: {filename}")
    
    try:
        # Récupérer le rapport JSON
        exploit_dir = "exploit_reports"
        file_path = os.path.join(exploit_dir, filename)
        
        if not os.path.exists(file_path):
            logger.warning(f"Rapport introuvable: {filename}")
            return jsonify({"error": "Rapport introuvable"}), 404
        
        # Sécuriser le chemin pour éviter les path traversal
        if not os.path.abspath(file_path).startswith(os.path.abspath(exploit_dir)):
            logger.warning(f"Tentative d'accès non autorisé: {file_path}")
            return jsonify({"error": "Accès non autorisé"}), 403
        
        with open(file_path, "r") as f:
            report = json.load(f)
        
        # Générer la date du rapport
        generated_on = datetime.datetime.now().strftime("%d/%m/%Y %H:%M:%S")
        
        # Rendre le template
        html_content = render_template("exploit_report.html", 
                                      report=report, 
                                      filename=filename,
                                      generated_on=generated_on)
        
        # Générer un nom de fichier pour le téléchargement
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        download_filename = f"exploit_report_{timestamp}.html"
        
        # Créer une réponse avec le contenu HTML
        response = make_response(html_content)
        response.headers["Content-Disposition"] = f"attachment; filename={download_filename}"
        response.headers["Content-Type"] = "text/html"
        
        return response
    except Exception as e:
        logger.error(f"Erreur lors de la génération du HTML: {e}", exc_info=True)
        return jsonify({"error": f"Erreur: {str(e)}"}), 500

@exploit_bp.route("/reports/<filename>/pdf", methods=["GET"])
def get_report_pdf(filename):
    """Génère et télécharge un rapport d'exploitation au format PDF"""
    logger.info(f"Génération du rapport PDF pour: {filename}")
    
    try:
        # Récupérer le rapport JSON
        exploit_dir = "exploit_reports"
        file_path = os.path.join(exploit_dir, filename)
        
        if not os.path.exists(file_path):
            logger.warning(f"Rapport introuvable: {filename}")
            return jsonify({"error": "Rapport introuvable"}), 404
        
        # Sécuriser le chemin pour éviter les path traversal
        if not os.path.abspath(file_path).startswith(os.path.abspath(exploit_dir)):
            logger.warning(f"Tentative d'accès non autorisé: {file_path}")
            return jsonify({"error": "Accès non autorisé"}), 403
        
        with open(file_path, "r") as f:
            report = json.load(f)
        
        # Préparer les données pour le rapport - AJOUT DU FLAG is_pdf_export
        report_data = {
            "module_name": "exploit",
            "target": report.get("target", "Inconnu"),
            "generated_on": datetime.datetime.now().strftime("%d/%m/%Y %H:%M:%S"),
            "report": report,
            "filename": filename,
            "is_pdf_export": True  # Ajouter cette variable
        }
        
        # Alternative: créer un template spécifique pour PDF
        from services.reporting_generator import generate_pdf_from_content
        
        # Générer d'abord le contenu HTML sans url_for
        html_content = render_template("exploit_report.html", **report_data)
        
        # Puis convertir ce contenu en PDF
        pdf_path = generate_pdf_from_content(html_content, f"exploit_report_{filename}.pdf")
        
        # Renvoyer le fichier PDF
        return send_file(pdf_path, as_attachment=True, download_name=f"exploit_report_{filename.replace('.json', '.pdf')}")
    except ImportError:
        logger.error("Module de génération de rapports non disponible")
        return jsonify({"error": "La génération de PDF n'est pas disponible"}), 500
    except Exception as e:
        logger.error(f"Erreur lors de la génération du PDF: {e}", exc_info=True)
        return jsonify({"error": f"Erreur: {str(e)}"}), 500

@exploit_bp.route("/available_exploits", methods=["GET"])
def get_available_exploits():
    """Récupère la liste des exploits disponibles"""
    logger.info("Récupération de la liste des exploits disponibles")
    
    try:
        return jsonify({"exploits": EXPLOIT_MAP})
    except Exception as e:
        logger.error(f"Erreur lors de la récupération des exploits: {e}", exc_info=True)
        return jsonify({"error": f"Erreur: {str(e)}"}), 500

@exploit_bp.route("/exploitability", methods=["POST"])
def check_exploitability():
    """Vérifie si une vulnérabilité est exploitable"""
    try:
        data = request.get_json()
        vulnerability = data.get("vulnerability")
        
        if not vulnerability:
            logger.warning("Paramètre 'vulnerability' manquant")
            return jsonify({"error": "Le paramètre 'vulnerability' est requis"}), 400
        
        logger.info(f"Vérification de l'exploitabilité de: {vulnerability}")
        
        # Vérifier dans la table des exploits
        exploit_module = None
        for vuln_id, module in EXPLOIT_MAP.items():
            if vuln_id.lower() in vulnerability.lower() or vulnerability.lower() in vuln_id.lower():
                exploit_module = module
                logger.info(f"Module trouvé pour {vulnerability}: {module}")
                break
        
        return jsonify({
            "exploitable": exploit_module is not None,
            "module": exploit_module,
            "vulnerability": vulnerability
        })
    except Exception as e:
        logger.error(f"Erreur lors de la vérification d'exploitabilité: {e}", exc_info=True)
        return jsonify({"error": f"Erreur: {str(e)}"}), 500

@exploit_bp.route("/network/local-ip", methods=["GET"])
def get_local_ip():
    """Récupère l'adresse IP locale de la machine"""
    try:
        # Obtenir l'adresse IP locale en se connectant à un serveur extérieur
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        # Nous n'avons pas besoin de nous connecter réellement
        s.connect(("8.8.8.8", 80))
        local_ip = s.getsockname()[0]
        s.close()
        
        logger.info(f"Adresse IP locale détectée: {local_ip}")
        return jsonify({"ip": local_ip})
    except Exception as e:
        logger.error(f"Erreur lors de la récupération de l'IP locale: {e}", exc_info=True)
        # En cas d'erreur, retourner une adresse IP locale par défaut
        return jsonify({"ip": "127.0.0.1", "error": str(e)})

def render_template_for_exploit_result(result, input_data):
    """
    Génère une page HTML pour afficher le résultat de l'exploitation
    """
    logger.debug("Génération du template pour les résultats d'exploitation")
    
    html_result = []
    
    # En-tête
    html_result.append("<h2>Résultat de l'exploitation</h2>")
    
    # Informations sur la cible
    html_result.append("<h3>Informations</h3>")
    html_result.append(f"<p><strong>Cible:</strong> {input_data.get('ip')}</p>")
    html_result.append(f"<p><strong>Port:</strong> {input_data.get('port')}</p>")
    html_result.append(f"<p><strong>Vulnérabilité:</strong> {input_data.get('vuln_id')}</p>")
    
    if result.get("module"):
        html_result.append(f"<p><strong>Module Metasploit:</strong> {result.get('module')}</p>")
    
    # Statut
    status = "Réussi" if result.get("success") else "Échec"
    status_class = "success" if result.get("success") else "danger"
    
    html_result.append(f'<div class="alert alert-{status_class}">')
    html_result.append(f'<h4>Statut: {status}</h4>')
    if result.get("error"):
        html_result.append(f'<p>{result.get("error")}</p>')
    html_result.append('</div>')
    
    # Sortie
    if result.get("output"):
        html_result.append("<h3>Sortie de Metasploit</h3>")
        html_result.append(f'<pre class="code-block">{result.get("output")}</pre>')
    
    # Rapport
    if result.get("report_file"):
        report_filename = os.path.basename(result.get("report_file"))
        html_result.append("<h3>Rapport</h3>")
        html_result.append(f'<p>Un rapport a été généré: <a href="/api/exploit/reports/{report_filename}" class="btn btn-info btn-sm">Voir le rapport</a>')
        html_result.append(f' <a href="/api/exploit/reports/{report_filename}/pdf" class="btn btn-danger btn-sm">Télécharger PDF</a></p>')
    
    # Actions supplémentaires
    html_result.append("<h3>Actions</h3>")
    html_result.append('<div class="btn-group">')
    html_result.append(f'<a href="/vuln" class="btn btn-primary">Retour au scan de vulnérabilités</a>')
    html_result.append(f'<a href="/exploits" class="btn btn-secondary">Voir tous les rapports</a>')
    
    # Si l'exploitation a réussi, offrir des actions post-exploitation
    if result.get("success"):
        target_ip = input_data.get('ip')
        html_result.append(f'<a href="/api/post_exploit/dashboard?target_ip={target_ip}" class="btn btn-success">Post-exploitation</a>')
    html_result.append('</div>')
    
    return render_template(
        "results.html", 
        title=f"Exploitation de {input_data.get('vuln_id')}", 
        result=[Markup(item) for item in html_result],
        module="exploit"
    )