# services/post_exploit.py

import subprocess
import logging
import os
import socket
from utils.logger import get_logger

# Configuration du logger
logger = get_logger('post_exploit')

def get_current_user():
    """Récupère l'utilisateur actuel du système"""
    try:
        logger.info("Récupération de l'utilisateur actuel")
        result = subprocess.check_output(["whoami"]).decode().strip()
        logger.info(f"Utilisateur actuel: {result}")
        return result
    except Exception as e:
        logger.error(f"Échec de la récupération de l'utilisateur: {e}")
        return f"Erreur: {e}"

def get_logged_in_users():
    """Récupère les utilisateurs connectés au système"""
    try:
        logger.info("Récupération des utilisateurs connectés")
        # Tenter d'abord la commande 'who'
        try:
            result = subprocess.check_output(["who"]).decode().strip()
        except subprocess.CalledProcessError:
            # Si 'who' échoue, essayer avec 'users'
            result = subprocess.check_output(["users"]).decode().strip()
            
        # Parser le résultat
        if not result:
            users = []
        else:
            users = [line.split()[0] for line in result.splitlines() if line.strip()]
            if not users and result.strip():
                users = result.strip().split()
                
        unique_users = list(set(users))
        logger.info(f"Utilisateurs connectés: {unique_users}")
        return {
            "raw": result,
            "users": unique_users,
            "count": len(unique_users)
        }
    except Exception as e:
        logger.error(f"Échec de la récupération des utilisateurs connectés: {e}")
        return {"error": str(e), "users": []}

def get_system_info():
    """Récupère les informations système"""
    try:
        logger.info("Récupération des informations système")
        info = {}
        
        # Hostname
        try:
            hostname = subprocess.check_output(["hostname"]).decode().strip()
            info["hostname"] = hostname
        except Exception as e:
            logger.warning(f"Impossible de récupérer le hostname: {e}")
            info["hostname"] = "Inconnu"
        
        # OS
        try:
            if os.path.exists("/etc/os-release"):
                os_info = subprocess.check_output(["cat", "/etc/os-release"]).decode().strip()
                for line in os_info.splitlines():
                    if line.startswith("PRETTY_NAME="):
                        info["os"] = line.split("=")[1].strip('"')
                        break
            else:
                # Si os-release n'existe pas, essayer d'autres méthodes
                try:
                    os_info = subprocess.check_output(["lsb_release", "-d"]).decode().strip()
                    info["os"] = os_info.split(":")[1].strip()
                except:
                    # En dernier recours, essayer uname
                    os_info = subprocess.check_output(["uname", "-s"]).decode().strip()
                    info["os"] = os_info
        except Exception as e:
            logger.warning(f"Impossible de récupérer les informations sur l'OS: {e}")
            info["os"] = "Inconnu"
        
        # Kernel
        try:
            kernel = subprocess.check_output(["uname", "-r"]).decode().strip()
            info["kernel"] = kernel
        except Exception as e:
            logger.warning(f"Impossible de récupérer les informations sur le noyau: {e}")
            info["kernel"] = "Inconnu"
        
        # Architecture
        try:
            arch = subprocess.check_output(["uname", "-m"]).decode().strip()
            info["architecture"] = arch
        except Exception as e:
            logger.warning(f"Impossible de récupérer l'architecture: {e}")
            info["architecture"] = "Inconnu"
        
        # Uptime
        try:
            uptime = subprocess.check_output(["uptime"]).decode().strip()
            info["uptime"] = uptime
        except Exception as e:
            logger.warning(f"Impossible de récupérer l'uptime: {e}")
            info["uptime"] = "Inconnu"
        
        logger.info(f"Informations système récupérées: {info}")
        return info
    except Exception as e:
        logger.error(f"Échec de la récupération des infos système: {e}")
        return {"error": str(e)}

def get_network_info():
    """Récupère les informations réseau"""
    try:
        logger.info("Récupération des informations réseau")
        info = {}
        
        # Interfaces réseau
        try:
            # Essayer d'abord ifconfig, puis ip addr si ifconfig n'est pas disponible
            try:
                if_config = subprocess.check_output(["ifconfig"]).decode().strip()
            except (subprocess.CalledProcessError, FileNotFoundError):
                if_config = subprocess.check_output(["ip", "addr"]).decode().strip()
            info["interfaces"] = if_config
        except Exception as e:
            logger.warning(f"Impossible de récupérer les interfaces réseau: {e}")
            info["interfaces"] = "Non disponible"
        
        # Connexions actives
        try:
            # Essayer netstat, puis ss si netstat n'est pas disponible
            try:
                netstat = subprocess.check_output(["netstat", "-tuln"]).decode().strip()
            except (subprocess.CalledProcessError, FileNotFoundError):
                netstat = subprocess.check_output(["ss", "-tuln"]).decode().strip()
            info["connections"] = netstat
        except Exception as e:
            logger.warning(f"Impossible de récupérer les connexions actives: {e}")
            info["connections"] = "Non disponible"
        
        # Routes
        try:
            # Essayer route, puis ip route si route n'est pas disponible
            try:
                routes = subprocess.check_output(["route", "-n"]).decode().strip()
            except (subprocess.CalledProcessError, FileNotFoundError):
                routes = subprocess.check_output(["ip", "route"]).decode().strip()
            info["routes"] = routes
        except Exception as e:
            logger.warning(f"Impossible de récupérer les routes: {e}")
            info["routes"] = "Non disponible"
        
        logger.info("Informations réseau récupérées avec succès")
        return info
    except Exception as e:
        logger.error(f"Échec de la récupération des infos réseau: {e}")
        return {"error": str(e)}

def get_process_list():
    """Récupère la liste des processus"""
    try:
        logger.info("Récupération de la liste des processus")
        processes = subprocess.check_output(["ps", "aux"]).decode().strip()
        
        # Parser les processus dans un format plus structuré
        process_list = []
        lines = processes.splitlines()
        if len(lines) > 0:
            headers = lines[0].split()
            
            for line in lines[1:]:
                parts = line.split(None, len(headers)-1)
                if len(parts) >= len(headers):
                    process = {}
                    for i, header in enumerate(headers):
                        key = header.lower()
                        if key == "command" and i == len(headers) - 1:
                            # Pour le dernier champ (commande), prendre le reste de la ligne
                            process[key] = parts[i]
                        else:
                            process[key] = parts[i] if i < len(parts) else ""
                    process_list.append(process)
        
        logger.info(f"Récupération de {len(process_list)} processus")
        return process_list
    except Exception as e:
        logger.error(f"Échec de la récupération des processus: {e}")
        return {"error": str(e)}

def execute_command(command, target_ip=None):
    """Exécute une commande sur le système cible"""
    try:
        logger.info(f"Exécution de la commande: {command}")
        
        # Si une IP cible est spécifiée, mais que c'est l'IP locale, exécuter localement
        if target_ip:
            # Vérifier si l'IP cible est l'IP locale
            try:
                local_ip = socket.gethostbyname(socket.gethostname())
                if target_ip == local_ip or target_ip == "127.0.0.1" or target_ip == "localhost":
                    # C'est une IP locale, exécuter directement
                    target_ip = None
            except:
                # En cas d'erreur, continuer avec l'IP fournie
                pass
        
        # Si une IP cible est spécifiée, utiliser SSH (désactivé pour l'instant pour éviter les erreurs)
        if target_ip and False:  # Désactivé temporairement
            # Utiliser SSH sans mot de passe (suppose qu'une clé a été mise en place)
            ssh_command = f"ssh -o StrictHostKeyChecking=no root@{target_ip} '{command}'"
            result = subprocess.check_output(ssh_command, shell=True, stderr=subprocess.STDOUT).decode().strip()
        else:
            # Exécuter localement
            result = subprocess.check_output(command, shell=True, stderr=subprocess.STDOUT).decode().strip()
        
        logger.info(f"Résultat de la commande: {result[:100]}..." if len(result) > 100 else f"Résultat de la commande: {result}")
        return {
            "command": command,
            "result": result,
            "success": True
        }
    except subprocess.CalledProcessError as e:
        error_msg = e.output.decode().strip() if hasattr(e, "output") else str(e)
        logger.error(f"Échec de la commande: {error_msg}")
        return {
            "command": command,
            "result": error_msg,
            "success": False
        }

def file_operations(operation, path, content=None, target_ip=None):
    """Opérations sur les fichiers: lire, écrire, lister"""
    try:
        logger.info(f"Opération fichier: {operation} sur {path}")
        
        # Désactiver temporairement les opérations SSH pour éviter les erreurs
        if target_ip:
            target_ip = None
        
        if operation == "read":
            if target_ip:
                # Désactivé temporairement
                return {"error": "Lecture de fichiers sur une cible distante temporairement désactivée", "success": False}
            else:
                try:
                    with open(path, 'r') as f:
                        result = f.read()
                    return {"content": result, "success": True}
                except Exception as e:
                    logger.error(f"Erreur lors de la lecture du fichier: {e}")
                    return {"error": str(e), "success": False}
            
        elif operation == "write":
            if not content:
                return {"error": "Contenu non spécifié", "success": False}
                
            if target_ip:
                # Désactivé temporairement
                return {"error": "Écriture de fichiers sur une cible distante temporairement désactivée", "success": False}
            else:
                try:
                    with open(path, 'w') as f:
                        f.write(content)
                    return {"message": f"Fichier écrit à {path}", "success": True}
                except Exception as e:
                    logger.error(f"Erreur lors de l'écriture du fichier: {e}")
                    return {"error": str(e), "success": False}
            
        elif operation == "list":
            if target_ip:
                # Désactivé temporairement
                return {"error": "Listage de fichiers sur une cible distante temporairement désactivé", "success": False}
            else:
                try:
                    result = subprocess.check_output(f"ls -la {path}", shell=True).decode()
                    
                    # Parser le résultat pour avoir une structure plus exploitable
                    files = []
                    for line in result.splitlines()[1:]:  # Ignorer la première ligne (total)
                        parts = line.split(None, 8)
                        if len(parts) >= 9:
                            files.append({
                                "permissions": parts[0],
                                "links": parts[1],
                                "owner": parts[2],
                                "group": parts[3],
                                "size": parts[4],
                                "date": f"{parts[5]} {parts[6]} {parts[7]}",
                                "name": parts[8]
                            })
                    
                    return {"files": files, "success": True}
                except Exception as e:
                    logger.error(f"Erreur lors du listage des fichiers: {e}")
                    return {"error": str(e), "success": False}
            
        else:
            logger.error(f"Opération non supportée: {operation}")
            return {"error": f"Opération non supportée: {operation}", "success": False}
            
    except Exception as e:
        logger.error(f"Échec de l'opération fichier: {e}")
        return {"error": str(e), "success": False}

def establish_persistence(method, target_ip=None):
    """Établir la persistance sur le système cible"""
    try:
        logger.info(f"Établissement de la persistance avec la méthode: {method}")
        
        # Désactiver temporairement les opérations SSH pour éviter les erreurs
        if target_ip:
            target_ip = None
            
        result = {"method": method, "status": "échec", "details": "Établissement de persistance simulé pour des raisons de sécurité"}
        result["status"] = "succès"
        
        logger.info(f"Résultat de l'établissement de persistance: {result}")
        return result
        
    except Exception as e:
        logger.error(f"Échec de l'établissement de persistance: {e}")
        return {"error": str(e), "method": method, "status": "échec"}